import ij.IJ;
import ij.gui.GenericDialog;
import ij.io.SaveDialog;
import ij.plugin.PlugIn;

import mpi.rc.IJ.IJutilities.ConcurrencyUtils;

import java.io.FileWriter;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public class Test_HydroCell_Circle_MultiCore implements PlugIn{

    /*
    Simulation of hydrodynamic interactions following the algorithm of Hernandez-Ortiz et al. J. Chem. Phys. (2006)
    This class is the PlugIn for computing the flow field generated by a single circular circle
    Reminder: the flow is v_k(r_target) = sum_sources sum_q c_{k,i}(r_target,q,b) a_{i,j}(r_source,q,b) f_j
     */

    private double[][] VXZx;
    private double[][] VXZz;

    private int nthreads = ConcurrencyUtils.getNumberOfThreads();
    private int count;

    final Object globalLock = new Object();

    @Override
    public void run(String arg) {

        // Grabbing parameters
        GenericDialog gd = new GenericDialog("params, z=0-H, x=0-Width");
        gd.addNumericField("nk",65,0);
        gd.addNumericField("L0",128,0);
        gd.addNumericField("a0 (Gaussian_cutOff)",0.5,1);
        gd.addNumericField("Circle_Radius", 10,1);
        gd.addNumericField("zM", 1.0,1);
        gd.addNumericField("Channel_height", 40,1);
        gd.addNumericField("Width", 64,0);
        gd.addNumericField("resolution_V", 5,0);
        gd.addNumericField("nTheta",100,0);

        gd.addCheckbox("dipole",true);
        gd.addNumericField("dipLength",2.0,1);

        gd.showDialog();

        int nk = (int) gd.getNextNumber(); // number of wave numbers for the Fourier expansion
        int L0 = (int) gd.getNextNumber(); // size of the simulation box for the Fourier expansion

        double a0 = gd.getNextNumber(); // Gaussian width for smoothing the point force

        double R = gd.getNextNumber(); // radius of the circular trajectory
        double z0 = gd.getNextNumber(); // z position of the circle
        double H = gd.getNextNumber(); // height of the channel
        int W = (int)gd.getNextNumber(); // width of the area over which the flow field is computed
        final int nx = (int)gd.getNextNumber(); // resolution of the grid over which the flow field is computed
        int nTheta = (int) gd.getNextNumber(); // number of angular positions over which the flow field is averaged

        final double zM= z0-H/2; // z position for the Ortiz algo (in [-H/2 H/2])

        final boolean dip = gd.getNextBoolean(); // do we compute for a dipole or a monopole?
        double ld = gd.getNextNumber()/2; // half the length of the dipole

        VXZx = new double[W*nx][(int)H*nx]; // output velocity in the x direction
        VXZz = new double[W*nx][(int)H*nx]; // output velocity in the z direction

        // the utilities to compute flow field
        HydroCell3.setConditions(H/2,L0,a0, nk);
        HydroTargetCoeffs2.setConditions(H/2,L0, nk);

        // parallelization block
        int p = nTheta / nthreads ; // parallelized loop on nTheta
        int dp = nTheta%nthreads; // leftover cells

        int nRuns = (nthreads<nTheta)?nthreads:nTheta;

        Future<?>[] futures = new Future[nRuns]; // setting the parallel threads

        int kmin = 0;

        for (int l = 0; l < nRuns; l++) {

            final int firstK = kmin;
            kmin += p+(l<dp?1:0); // leftover thetas are spread over the dp first threads
            final int lastK = kmin;//( l == (nRuns-1))? (Ncells) : (firstK + p);

            futures[l] = ConcurrencyUtils.submit( () ->
            {

                HydroCell3 dipVCalc = new HydroCell3(); // point source, flagellum

                HydroCell3 exsVCalc = new HydroCell3(); // point source, body

                HydroTargetCoeffs2 nM = new HydroTargetCoeffs2(); // target point

                double vc[];
                double theta,xM, yM, ux,uy;
                double xD = 0, yD = 0;

                for(int i=firstK; i<lastK; i++){

                    // show progress
                    synchronized(VXZx) {
                        count++;
                    }
                    IJ.showProgress((double)count/nTheta);
                    //code

                    theta = 2*i * Math.PI / nTheta;

                    ux = - Math.sin(theta); // swimming direction
                    uy = Math.cos(theta);

                    xM = R*Math.cos(theta); // position of the point
                    yM = R*Math.sin(theta);

                    if (dip) { // positions of flagellum and cell body
                        xD = xM - ld * ux;
                        yD = yM - ld * uy;

                        xM += ld * ux;
                        yM += ld * uy;

                        dipVCalc.calcAfs(xD, yD, zM, -ux, -uy, 0); // flagellum flow source
                    }

                    exsVCalc.calcAfs(xM, yM, zM, ux, uy, 0); // cell body flow source

                    // loop on the grid positions
                    for (int x = 0; x < VXZx.length; x++) {
                        for (int z = 0; z < VXZx[0].length; z++) {
                            double xx = 0 + (double) x / nx;
                            double zz = -H/2 + (double) z / nx;

                            if ((xx - xM) != 0.0 || (zz - zM) != 0.0 || (yM) != 0.0) {

                                nM.setPosition(xx, 0.0, zz);

                                vc = exsVCalc.getVelocity(nM); // get velocity body

                                synchronized(VXZx[x]) {
                                    VXZx[x][z] -= vc[0];
                                    VXZz[x][z] -= vc[2];
                                }


                                if (dip && ((xx - xD) != 0.0 || (zz - zM) != 0.0 || (yD) != 0.0)) {

                                    vc = dipVCalc.getVelocity(nM); // get velocity flagellum

                                    synchronized(VXZx[x]) {
                                        VXZx[x][z] -= vc[0];
                                        VXZz[x][z] -= vc[2];
                                    }

                                }
                            }
                        }

                    }

                }

            });
        }
        waitForCompletion(futures,"ComputeVelocity");
        //end parallelisation block

        // normalization
        for (int x = 0; x < VXZx.length; x++) {
            for (int z = 0; z < VXZx[0].length; z++) {
                VXZx[x][z] /= nTheta;
                VXZz[x][z] /= nTheta;
            }
        }

        // save the velocity maps
        save(VXZx,"fileName_VX","vX_X-0-"+W+"_Z-0-"+H+"_res-"+1.0/nx+"_R-"+R+"_zM-"+(z0)+"_nk-"+nk);
        save(VXZz,"fileName_VY","vZ_X-0-"+W+"_Z-0-"+H+"_res-"+1.0/nx+"_R-"+R+"_zM-"+(z0)+"_nk-"+nk);

    }

    public void save(double[][] v, String name, String title){

        // get save file name
        SaveDialog sd = new SaveDialog(name,title,".txt");
        String filename = sd.getDirectory()+sd.getFileName();

        // write the file
        write(v,filename);

    }

    private void write(double[][] v,String filename){

        String lineSep = System.lineSeparator();

        try {
            FileWriter file = new FileWriter(filename);
            for(int i=0;i<v.length;i++){
                String buffer=""+v[i][0];
                for(int j=1;j<v[0].length;j++){
                    buffer+="\t"+v[i][j];
                }
                buffer+=lineSep;
                file.write(buffer);
            }

            file.close();
        } catch (Exception e){
            IJ.log("Erreur doSave --> "+e.getMessage());
            IJ.log("Erreur doSave --> "+e.getCause());
            IJ.log("Erreur doSave --> "+e.getLocalizedMessage());
        }

        IJ.showStatus("Done");

    }

    private void waitForCompletion(Future<?>[] futures, String name) {
        try {
            ConcurrencyUtils.waitForCompletion(futures);
        } catch (InterruptedException ex) {
            IJ.log("Interruption Exception "+name);
            //IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        } catch (ExecutionException ex) {
            IJ.log("Execution Exception "+name);
            //IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        }
    }


}
