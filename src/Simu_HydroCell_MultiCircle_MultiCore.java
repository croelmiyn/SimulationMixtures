import ij.IJ;
import ij.ImagePlus;
import ij.gui.GenericDialog;
import ij.io.SaveDialog;
import ij.plugin.PlugIn;
import ij.process.ImageProcessor;
import mpi.rc.IJ.IJutilities.ConcurrencyUtils;
import mpi.rc.IJ.IJutilities.MersenneTwister;

import java.io.FileWriter;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import static mpi.rc.IJ.IJutilities.MatrixParallelUtils.toFloat;

public class Simu_HydroCell_MultiCircle_MultiCore implements PlugIn{

    /*
    Simulation of hydrodynamic interactions following the algorithm of Hernandez-Ortiz et al. J. Chem. Phys. (2006)
    This class is the PlugIn for computing the flow field generated by many circular swimmers
    Reminder: the flow is v_k(r_target) = sum_sources sum_q c_{k,i}(r_target,q,b) a_{i,j}(r_source,q,b) f_j
     */

    private double[][][] Vx; // flow field in 3D
    private double[][][] Vy;
    private double[][][] Vz;

    private int Nc; // number of circular swimmers

    private int nthreads = ConcurrencyUtils.getNumberOfThreads();
    private int count;

    final Object globalLock = new Object();

    final private MersenneTwister rd = new MersenneTwister();

    @Override
    public void run(String arg) {

        // getting the simulation parameters
        GenericDialog gd = new GenericDialog("params, z=0-H, x=0-Width");
        gd.addNumericField("nk",127,0);
        gd.addNumericField("L0",128,0);
        gd.addNumericField("Ncells",100,0);
        gd.addNumericField("a0 (Cell_body_Size)",0.3,1);
        gd.addNumericField("zM", 0.5,1);
        gd.addNumericField("Channel_height", 20,1);
        gd.addNumericField("Width", 128,0);
        gd.addNumericField("resolution", 2,0);
        gd.addNumericField("nTheta",100,0);

        gd.addNumericField("dipLength",2.0,1);

        gd.showDialog();

        int nk = (int) gd.getNextNumber(); // number of wave numbers for the Fourier expansion
        int L0 = (int) gd.getNextNumber(); // size of the simulation box for the Fourier expansion (px)

        Nc = (int)gd.getNextNumber(); // number of circular swimmers
        double a0 = gd.getNextNumber(); // Gaussian width for smoothing the point force

        double z0 = gd.getNextNumber(); // z position of the circles (px)
        double H = gd.getNextNumber(); // height of the channel (px)
        int W = (int)gd.getNextNumber(); // width of the area over which the flow field is computed (px)
        final int nx = (int)gd.getNextNumber(); // resolution of the grid over which the flow field is computed: 1 px = nx um
        int nTheta = (int) gd.getNextNumber(); // number of angular positions over which the flow field is averaged for a circle

        final double zM= z0-H/2; // z position for the Ortiz algo (in [-H/2 H/2])

        double ld = gd.getNextNumber()/2; // half the length of the dipole (px)

        // set up of the flow field utilities
        HydroCell3.setConditions(H/2,L0,a0, nk);
        HydroTargetCoeffs2.setConditions(H/2,L0, nk);

        // sum of the flow sources for motiles at the top and bottom walls
        final double[][] lambda_at = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_at = new double[4]; // for targets above motile on top

        final double[][] lambda_bt = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_bt = new double[4]; // for targets below motile on top

        final double[][] lambda_ab = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_ab = new double[4]; // for targets above motile at bottom

        final double[][] lambda_bb = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_bb = new double[4]; // for targets below motile at bottom

        // params of the distrib of radii (assumes normal sized cells)
        final double l1 = 0.2;
        final double l2 = 0.15;
        final double mu = -1.5;
        final double f = l1/(l1+l2);


        // setting the sources of flow
        // parallelization block
        int p = Nc / nthreads ; // parallel loop on the circles
        int dp = Nc%nthreads; // leftover cells

        int nRuns = (nthreads<Nc)?nthreads:Nc;

        Future<?>[] futures = new Future[nRuns];

        int kmin = 0;

        for (int l = 0; l < nRuns; l++) {

            final int firstK = kmin;
            kmin += p+(l<dp?1:0); // leftover thetas are spread over the dp first threads
            final int lastK = kmin;//( l == (nRuns-1))? (Ncells) : (firstK + p);

            futures[l] = ConcurrencyUtils.submit( () ->
            {

                HydroCell3 hydro_source_b = new HydroCell3(); // cell body
                HydroCell3 hydro_source_d = new HydroCell3(); // flagellum

                double xc,yc,sc,rad;
                double theta,xM, yM, ux,uy;
                double xD , yD;

                for(int k=firstK; k<lastK; k++){

                    // show progress
                    synchronized(globalLock) {
                        count++;
                        IJ.showProgress((double)count/Nc);
                        IJ.showStatus("Compute Flow Sources");
                    }

                    //code

                    // pick position and radius of circle
                    synchronized (rd) {
                        xc = rd.nextDouble()*W;
                        yc = rd.nextDouble()*W;
                        sc = (rd.nextDouble()<0.5)?1:-1; // z location: 1 = bottom wall, -1 = top wall, half/half probability
                        double e = rd.nextDouble();
                        double logC = (e<f)? (mu+l1*Math.log(e/f)) : (mu-l2*Math.log(1-(e-f)/(1-f))) ; // Exponential distributions of radii
                        rad = Math.pow(10,-logC)/nx; // 1 unit = nx mum standard
                    }

                    for(int i=0; i<nTheta; i++) { // loop over the positions around the circle

                        theta = 2 * i * Math.PI / nTheta;

                        ux = -Math.sin(theta); // velocity tangential to the circle
                        uy = Math.cos(theta);

                        xM = xc + rad * Math.cos(theta); // position
                        yM = yc + rad * Math.sin(theta);

                        xD = xM - ld * ux; // position of flagellum
                        yD = yM - ld * uy;
                        xM += ld * ux;  // position of cell body
                        yM += ld * uy;

                        // update force * nCircles ~ 1/rad
                        //ux /=rad; we compute the mean flow speed
                        //uy /=rad;

                        hydro_source_b = new HydroCell3();
                        hydro_source_d = new HydroCell3();

                        hydro_source_b.calcAfs(xM, yM, sc*zM, ux, uy, 0);
                        synchronized (globalLock) {
                            if(sc<0) { // source on top wall
                                hydro_source_b.addAF(lambda_at, cF_at, false);
                                hydro_source_b.addAF(lambda_bt, cF_bt, true); // target below the source
                            }
                            else{ //source on bottom wall
                                hydro_source_b.addAF(lambda_ab, cF_ab, false);
                                hydro_source_b.addAF(lambda_bb, cF_bb, true); // target below the source
                            }
                        }

                        hydro_source_d.calcAfs(xD, yD, sc*zM, -ux, -uy, 0);
                        synchronized (globalLock) {
                            if(sc<0) { // source on top wall
                                hydro_source_d.addAF(lambda_at, cF_at, false);
                                hydro_source_d.addAF(lambda_bt, cF_bt, true); // target below the source
                            }
                            else { //source on bottom wall
                                hydro_source_d.addAF(lambda_ab, cF_ab, false);
                                hydro_source_d.addAF(lambda_bb, cF_bb, true); // target below the source
                            }
                        }


                    }

                }

            });
        }
        waitForCompletion(futures,"ComputeFlowSources"); // safe execution of the threads
        //end parallelisation block

        // Calculation of the flow fields

        int Nz = (int)H*nx; // resolution of the grid = 1 um

        Vx = new double[Nz][W*nx][W*nx]; // velocity, resolution of the grid = 1 um
        Vy = new double[Nz][W*nx][W*nx];
        Vz = new double[Nz][W*nx][W*nx];

        // parallelization block
        p = Nz / nthreads ; // parallel run over the z positions
        dp = Nz%nthreads; // leftovers

        nRuns = (nthreads<Nz)?nthreads:Nz;

        futures = new Future[nRuns];

        kmin = 0;
        count = 0;

        for (int l = 0; l < nRuns; l++) {

            final int firstK = kmin;
            kmin += p+(l<dp?1:0); // leftover thetas are spread over the dp first threads
            final int lastK = kmin;//( l == (nRuns-1))? (Ncells) : (firstK + p);

            futures[l] = ConcurrencyUtils.submit( () ->
            {

                // code
                double vc[];
                HydroTargetCoeffs2 nM;

                for(int k=firstK; k<lastK; k++){

                    // show progress
                    synchronized(globalLock) {
                        count++;
                        IJ.showProgress((double)count/Nz);
                        IJ.showStatus("Compute Flow Map");
                    }

                    nM = new HydroTargetCoeffs2();

                    double[][] vxl = Vx[k]; // handles for v at the height k
                    double[][] vyl = Vy[k];
                    double[][] vzl = Vz[k];

                    double zz = -H/2 + (double) k / nx; // z position of k in the Ortiz frame of reference

                    boolean bt = zz<-zM; // zz below the top layer of circles?
                    boolean bb = zz<zM; // zz below the bottom layer of circles?

                    double[][] lambda_t = bt?lambda_bt:lambda_at; // select appropriate sum of flow sources for top wall
                    double[] cF_t = bt?cF_bt:cF_at;
                    double[][] lambda_b = bb?lambda_bb:lambda_ab; // select appropriate sum of flow sources for bottom wall
                    double[] cF_b = bb?cF_bb:cF_ab;

                    for (int x = 0; x < vxl.length; x++) {
                        for (int y = 0; y < vxl[0].length; y++) {
                            double xx = (double) x / nx;
                            double yy = (double) y / nx;

                            nM.setPosition(xx, yy, zz);
                            vc = nM.getVelocity(lambda_t,cF_t,bt); // compute contribution of top wall cells
                            vxl[x][y]-=vc[0];
                            vyl[x][y]-=vc[1];
                            vzl[x][y]-=vc[2];

                            vc = nM.getVelocity(lambda_b,cF_b,bb); // compute contribution of bottom wall cells
                            vxl[x][y]-=vc[0];
                            vyl[x][y]-=vc[1];
                            vzl[x][y]-=vc[2];

                            vxl[x][y] /= nTheta;
                            vyl[x][y] /= nTheta;
                            vzl[x][y] /= nTheta;
                        }
                    }
                }

            });
        }
        waitForCompletion(futures,"ComputeFlows"); // safe execution of the threads
        //end parallelisation block

        // output of the velocity components as 3D image stacks
        ImagePlus impX = IJ.createImage("Vx","32-bit",nx*W,nx*W,Nz);
        ImagePlus impY = IJ.createImage("Vy","32-bit",nx*W,nx*W,Nz);
        ImagePlus impZ = IJ.createImage("Vz","32-bit",nx*W,nx*W,Nz);
        ImageProcessor ipX = impX.getProcessor();
        ImageProcessor ipY = impY.getProcessor();
        ImageProcessor ipZ = impZ.getProcessor();

        // loop over the z positions
        for(int z=1;z<=Nz;z++){
            impX.setSlice(z);
            impY.setSlice(z);
            impZ.setSlice(z);

            ipX.setFloatArray(toFloat(Vx[z-1]));
            ipY.setFloatArray(toFloat(Vy[z-1]));
            ipZ.setFloatArray(toFloat(Vz[z-1]));

        }
        impX.show();
        impY.show();
        impZ.show();

        //save(VXZx,"fileName_VX","vX_X-0-"+W+"_Z-0-"+H+"_res-"+1.0/nx+"_R-"+R+"_zM-"+(z0)+"_nk-"+nk);
        //save(VXZz,"fileName_VY","vZ_X-0-"+W+"_Z-0-"+H+"_res-"+1.0/nx+"_R-"+R+"_zM-"+(z0)+"_nk-"+nk);
        // deprecated, too memory costly

    }

    public void save(double[][] v, String name, String title){

        SaveDialog sd = new SaveDialog(name,title,".txt");
        String filename = sd.getDirectory()+sd.getFileName();

        write(v,filename);

    }

    private void write(double[][] v,String filename){

        String lineSep = System.lineSeparator();

        try {
            FileWriter file = new FileWriter(filename);
            for(int i=0;i<v.length;i++){
                String buffer=""+v[i][0];
                for(int j=1;j<v[0].length;j++){
                    buffer+="\t"+v[i][j];
                }
                buffer+=lineSep;
                file.write(buffer);
            }

            file.close();
        } catch (Exception e){
            IJ.log("Erreur doSave --> "+e.getMessage());
            IJ.log("Erreur doSave --> "+e.getCause());
            IJ.log("Erreur doSave --> "+e.getLocalizedMessage());
        }

        IJ.showStatus("Done");

    }

    private void waitForCompletion(Future<?>[] futures, String name) {
        try {
            ConcurrencyUtils.waitForCompletion(futures);
        } catch (InterruptedException ex) {
            IJ.log("Interruption Exception "+name);
            //IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        } catch (ExecutionException ex) {
            IJ.log("Execution Exception "+name);
            //IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        }
    }


}
