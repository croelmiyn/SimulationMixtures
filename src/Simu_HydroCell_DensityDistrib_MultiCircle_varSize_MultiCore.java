import ij.IJ;
import ij.ImagePlus;
import ij.gui.GenericDialog;
import ij.io.LogStream;
import ij.io.SaveDialog;
import ij.plugin.PlugIn;
import ij.process.ImageProcessor;
import mpi.rc.IJ.IJutilities.ConcurrencyUtils;
import mpi.rc.IJ.IJutilities.MersenneTwister;

import java.io.FileWriter;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

public class Simu_HydroCell_DensityDistrib_MultiCircle_varSize_MultiCore implements PlugIn{

    /*
    Simulation of hydrodynamic interactions following the algorithm of Hernandez-Ortiz et al. J. Chem. Phys. (2006)
    This class is the PlugIn for computing tracer motion in the flow field generated by many circular swimmers at the walls
    Reminder: the flow is v_k(r_target) = sum_sources sum_q c_{k,i}(r_target,q,b) a_{i,j}(r_source,q,b) f_j
    the flow field is the average flow field, which is constant, because the configuration of swimmers is constant, throughout the simulatio
     */

    private double[][] Xt;
    private double[][] Yt;
    private double[][] Zt;

    private int Nc;

    private int Nt,T;

    private int nthreads = ConcurrencyUtils.getNumberOfThreads();
    private int count;

    final Object globalLock = new Object();

    final private MersenneTwister rd = new MersenneTwister(); // random number generator

    @Override
    public void run(String arg) {

        LogStream.redirectSystem();

        // grabbing simulation parameters
        GenericDialog gd = new GenericDialog("params, z=0-H, x=0-Width");
        gd.addNumericField("nk",127,0);
        gd.addNumericField("L0 (px)",128,0);
        gd.addNumericField("Ncells",100,0);
        gd.addNumericField("a0 (Gaussian_Cutoff_Hydro_Force, px)",0.3,1);
        gd.addNumericField("aS (Swimmer_Hydro_Rad, px)",0.35,1); //set to 0.55 for CPX, i.e. 0.7 µm for WT, 1.1 µm forCPX
        gd.addNumericField("zM (px)", 0.5,1);
        gd.addNumericField("Channel_height (px)", 20,1);
        gd.addNumericField("Width (px)", 128,0);
        gd.addNumericField("resolution (um/px)", 2,0);
        gd.addNumericField("nTheta",100,0);

        gd.addNumericField("dipLength",2.0,1);

        gd.addNumericField("N_tracers",1000,0);
        gd.addNumericField("timeSteps",1000,0);


        gd.addNumericField("Dtracers (um2/s)",0.3,1);
        gd.addNumericField("vSed (um/s)",0.05,2);
        gd.addNumericField("v0 (um/s)",20,1);
        gd.addNumericField("dt (s)",0.1,2);

        gd.addNumericField("h (print)",8,1);

        gd.addCheckbox("ElongatedCells",false);

        gd.showDialog();

        int nk = (int) gd.getNextNumber(); // number of wave numbers for the Fourier expansion
        int L0 = (int) gd.getNextNumber(); // size of the simulation box for the Fourier expansion (px)

        Nc = (int)gd.getNextNumber(); // number of circular swimmers
        double a0 = gd.getNextNumber(); // Gaussian cutoff for smoothing the force
        double aS = gd.getNextNumber(); // Swimmer size (px)

        double z0 = gd.getNextNumber(); // z position of the circles relative to the closest wall (px)
        double H = gd.getNextNumber();  // height of the channel (px)
        int W = (int)gd.getNextNumber(); // width of the simulation box (px)
        final int nx = (int)gd.getNextNumber(); // resolution of the grid over which the flow field is computed: 1 px = nx µm
        int nTheta = (int) gd.getNextNumber(); // number of angular positions over which the flow field is averaged for a circle

        final double zM= z0-H/2; // circle position in the Ortiz frame of reference, [-H/2 H/2]

        double ld = gd.getNextNumber()/2; // half the length of the dipole

        Nt= (int)gd.getNextNumber(); // number of tracers
        T = (int)gd.getNextNumber(); // number of time points

        double D = gd.getNextNumber(); // diffusion coefficient of the tracers (µm2/s)
        double vs = gd.getNextNumber(); // sedimentation speed (µm/s)
        double v0 = gd.getNextNumber(); // swimming speed of the swimmers (µm/s)
        double dt = gd.getNextNumber(); // time resolution of the simulation (s)

        double h = gd.getNextNumber(); // height at which the distribution of swimmers is printed
        boolean elongated = gd.getNextBoolean(); // are we simulating elongated swimmers? (for distrib of radi)

        // setup flow field computation utilities
        HydroCell3.setConditions(H/2,L0,a0, nk);
        HydroTargetCoeffs2.setConditions(H/2,L0, nk);

        // setup sum of point source contributions for cells at top and bottom walls
        final double[][] lambda_at = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_at = new double[4]; // target above motile on top

        final double[][] lambda_bt = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_bt = new double[4]; // target below motile on top

        final double[][] lambda_ab = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_ab = new double[4]; // target above motile at bottom

        final double[][] lambda_bb = new double[6][HydroCell3.nk2]; // aF1,2,3 x _re + _im
        final double[] cF_bb = new double[4]; // target below motile at bottom

        // params of the distrib of radii
        final double l1 = (elongated)?0.16:0.20;
        final double l2 = (elongated)?0.18:0.15;
        final double mu = (elongated)?-1.8:-1.5;
        final double f = l1/(l1+l2);

        final double v0dtNnTheta = aS*(v0*dt)/nTheta; // scaling by the relative swimmer size, in the final units (px*um)
        // aS = hydrodynamic size of the swimmers in px of the hydrodynamic calculation grid

        // compute the average sources of flow: constant throughout the simulation
        // parallelization block
        int p = Nc / nthreads ; // for loop on circular swimmers
        int dp = Nc%nthreads; // leftover cells

        int nRuns = (nthreads<Nc)?nthreads:Nc;

        Future<?>[] futures = new Future[nRuns];

        int kmin = 0;

        for (int l = 0; l < nRuns; l++) {

            final int firstK = kmin;
            kmin += p+(l<dp?1:0); // leftover thetas are spread over the dp first threads
            final int lastK = kmin;//( l == (nRuns-1))? (Ncells) : (firstK + p);

            futures[l] = ConcurrencyUtils.submit( () ->
            {

                HydroCell3 hydro_source_b = new HydroCell3(); // cell body
                HydroCell3 hydro_source_d = new HydroCell3(); // flagellum


                double xc,yc,sc,rad;
                double theta,xM, yM, ux,uy;
                double xD , yD;

                for(int k=firstK; k<lastK; k++){

                    // show progress
                    synchronized(globalLock) {
                        count++;
                        IJ.showProgress((double)count/Nc);
                        IJ.showStatus("Compute Flow Sources");
                    }

                    //code

                    // pick position and radius of circle
                    synchronized (rd) { // synchronized for unique random number generator
                        xc = rd.nextDouble()*W;
                        yc = rd.nextDouble()*W;
                        sc = (rd.nextDouble()<0.5)?1:-1; // 1 = at the bottom, -1 = at the top
                        double e = rd.nextDouble();
                        double logC = (e<f)? (mu+l1*Math.log(e/f)) : (mu-l2*Math.log(1-(e-f)/(1-f))) ; // exponential distributions
                        rad = Math.pow(10,-logC)/nx; // 1 unit = nx mum standard
                    }

                    for(int i=0; i<nTheta; i++) {

                        theta = 2 * i * Math.PI / nTheta;

                        ux = -Math.sin(theta);  // direction of swimming tangential to circle
                        uy = Math.cos(theta);

                        xM = xc + rad * Math.cos(theta);
                        yM = yc + rad * Math.sin(theta);

                        xD = xM - ld * ux; // position of flagellum
                        yD = yM - ld * uy;
                        xM += ld * ux; // position of cell body
                        yM += ld * uy;

                        // normalization by v0dt/nTheta here for speed and to avoid byte overflow
                        ux *=v0dtNnTheta;
                        uy *=v0dtNnTheta;
                        // (ux,uy) is now the normalized force: ux = fx/6 pi eta = aS * v0 * cosPhi, in units (px*um)

                        hydro_source_b = new HydroCell3(); // cell body
                        hydro_source_d = new HydroCell3(); // flagellum

                        hydro_source_b.calcAfs(xM, yM, sc*zM, ux, uy, 0);
                        synchronized (globalLock) {
                            if(sc<0) { // source on top wall
                                hydro_source_b.addAF(lambda_at, cF_at, false);
                                hydro_source_b.addAF(lambda_bt, cF_bt, true); // target below the source
                            }
                            else{ //source on bottom wall
                                hydro_source_b.addAF(lambda_ab, cF_ab, false);
                                hydro_source_b.addAF(lambda_bb, cF_bb, true); // target below the source
                            }
                        }

                        hydro_source_d.calcAfs(xD, yD, sc*zM, -ux, -uy, 0);
                        synchronized (globalLock) {
                            if(sc<0) { // source on top wall
                                hydro_source_d.addAF(lambda_at, cF_at, false);
                                hydro_source_d.addAF(lambda_bt, cF_bt, true); // target below the source
                            }
                            else { //source on bottom wall
                                hydro_source_d.addAF(lambda_ab, cF_ab, false);
                                hydro_source_d.addAF(lambda_bb, cF_bb, true); // target below the source
                            }
                        }


                    }

                }

            });
        }
        waitForCompletion(futures,"ComputeFlowSources");
        //end parallelisation block

        // Calculation of the density distrib

        Xt = new double[Nt][T]; // positions of the tracers
        Yt = new double[Nt][T];
        Zt = new double[Nt][T];

        final double sqrt2D = Math.sqrt(2*D*dt); // for Brownian noise calculation
        final double hs = D/vs; // sedimentation length (µm)
        // final double v0dt = v0*dt; not useful anymore
        final double vsdt = vs*dt;

        double eta,c = (1-Math.exp(-H*nx/hs));

        // initialize positions of the tracers
        for(int k=0;k<Nt;k++){
            Xt[k][0]=rd.nextDouble()*W*nx; // positions in µm
            Yt[k][0]=rd.nextDouble()*W*nx;
            eta = rd.nextDouble();
            Zt[k][0]=-hs*Math.log(1-eta*c); // Boltzmann distribution
        }

        // parallelization block
        p = Nt / nthreads ; // parallel run over the tracers
        dp = Nt%nthreads; // leftovers

        nRuns = (nthreads<Nt)?nthreads:Nt;

        futures = new Future[nRuns];

        kmin = 0;
        count = 0;

        for (int l = 0; l < nRuns; l++) {

            final int firstK = kmin;
            kmin += p+(l<dp?1:0); // leftover tracers are spread over the dp first threads
            final int lastK = kmin;

            futures[l] = ConcurrencyUtils.submit( () ->
            {

                // code
                double vc[], vl[];
                HydroTargetCoeffs2 nM;

                for(int k=firstK; k<lastK; k++){

                    // show progress
                    synchronized(globalLock) {
                        count++;
                        IJ.showProgress((double)count/Nt);
                        IJ.showStatus("Compute Flow Map");
                    }

                    double[] xl = Xt[k]; // handle for position of the current tracer
                    double[] yl = Yt[k];
                    double[] zl = Zt[k];

                    for(int t=1; t<T; t++){ // loop over the time points

                        nM = new HydroTargetCoeffs2(); // setup flow target
                        vl = new double[3];

                        double zz = -H/2 + zl[t-1]/nx; // shift + conversion to px (resolution of flow)

                        boolean bt = zz<-zM; // zz below the top layer of circles?
                        boolean bb = zz<zM; // zz below the bottom layer of circles?

                        double[][] lambda_t = bt?lambda_bt:lambda_at; // select appropriate sum of point sources at top wall
                        double[] cF_t = bt?cF_bt:cF_at;
                        double[][] lambda_b = bb?lambda_bb:lambda_ab; // select appropriate sum of point sources at bottom wall
                        double[] cF_b = bb?cF_bb:cF_ab;

                        nM.setPosition(xl[t-1]/nx, yl[t-1]/nx, zz); // target, positions in px of the hydro flow calculation

                        // hydro
                        vc = nM.getVelocity(lambda_t,cF_t,bt); // contribution of top wall cells
                        vl[0]-=vc[0]; // already normed by v0*dt at the nThetaN level
                        vl[1]-=vc[1];
                        vl[2]-=vc[2];

                        vc = nM.getVelocity(lambda_b,cF_b,bb); // contribution of bottom wall cells
                        vl[0]-=vc[0];
                        vl[1]-=vc[1];
                        vl[2]-=vc[2];

                        // sedimentation
                        vl[2]-=vsdt;

                        // Brownian motion
                        synchronized(rd) { // synchronization because unique random number generator
                            vl[0]+=sqrt2D*rd.nextGaussian();
                            vl[1]+=sqrt2D*rd.nextGaussian();
                            vl[2]+=sqrt2D*rd.nextGaussian();
                        }

                        xl[t] = xl[t-1]+vl[0];
                        yl[t] = yl[t-1]+vl[1];
                        zl[t] = zl[t-1]+vl[2];

                        // boundary conditions (x,y,z)=(periodic,periodic,reflexive)
                        if(zl[t]<0){
                            zl[t] = zl[t-1];
                        }
                        if(zl[t]>H*nx){
                            zl[t] = zl[t-1];
                        }
                        xl[t] -= Math.floor(xl[t]/(W*nx))*(W*nx);
                        yl[t] -= Math.floor(yl[t]/(W*nx))*(W*nx);

                    }

                }

            });
        }
        waitForCompletion(futures,"ComputeFlows");
        //end parallelisation block

        // print pseudo microscopy image at height h
        ImagePlus impX = print(Xt,Yt,Zt, h,W,nx);

        impX.show();

        // save the data
        save(Xt,"fileName_X","X_NxT_l0-"+(L0)+"_nk-"+nk);
        save(Yt,"fileName_Y","Y_NxT_l0-"+(L0)+"_nk-"+nk);
        save(Zt,"fileName_Z","Z_NxT_l0-"+(L0)+"_nk-"+nk);

    }

    public void save(double[][] v, String name, String title){

        SaveDialog sd = new SaveDialog(name,title,".txt");
        String filename = sd.getDirectory()+sd.getFileName();

        write(v,filename);

    }

    private void write(double[][] v,String filename){

        String lineSep = System.lineSeparator();

        try {
            FileWriter file = new FileWriter(filename);
            for(int i=0;i<v.length;i++){
                String buffer=""+v[i][0];
                for(int j=1;j<v[0].length;j++){
                    buffer+="\t"+v[i][j];
                }
                buffer+=lineSep;
                file.write(buffer);
            }

            file.close();
        } catch (Exception e){
            IJ.log("Erreur doSave --> "+e.getMessage());
            IJ.log("Erreur doSave --> "+e.getCause());
            IJ.log("Erreur doSave --> "+e.getLocalizedMessage());
        }

        IJ.showStatus("Done");

    }

    private ImagePlus print(double[][] X,double[][] Y,double[][] Z, double h,double W,double nx){

        ImagePlus imp = IJ.createImage("XY_h-"+h,"32-bit",(int)(W*nx),(int)(W*nx),1,1,X[0].length);
        ImageProcessor ip = imp.getProcessor();

        for(int t=0;t<X[0].length;t++){ // loop over the time points
            IJ.showProgress((double)t/X[0].length);

            imp.setT(t+1);

            drawParticles(ip,X,Y,Z,t,h); // draw the image at time t

        }

        return imp;

    }

    private void drawParticles(ImageProcessor ip1,  double[][] X, double[][] Y, double[][] Z, int t,double h){

        int xmin,xmax,ymin,ymax;

        double px,yl,xl,s2,s,as2;

        int widthInt = ip1.getWidth();

        double a=1.0, dh = 4.0; // a = tracer diameters in µm, dh = depth of field in µm

        for(int k=0; k<X.length;k++){ // loop over the tracers

            s = (Z[k][t]-h)/dh;  // relative distance to the focal plane
            s2 = 1+3*s*s;
            as2 = a*a*s2/2;

            xmin = (int) ( (X[k][t]-3*a) ); // cutoff for speed
            xmax = (int) ( (X[k][t]+3*a) );
            ymin = (int) ( (Y[k][t]-3*a) );
            ymax = (int) ( (Y[k][t]+3*a) );


            for(int xx=xmin; xx<=xmax; xx++){ //loop over the pixels surrounding the position of the tracer

                for(int yy=ymin; yy<=ymax; yy++){
                    //if(( (xx-res*X[k])*(xx-res*X[k]) +(yy-res*Y[k])*(yy-res*Y[k])) <= res*res*a*a ){
                    // retrieve pixel value, with periodic boundary conditions
                    px = ip1.getPixelValue(xx-(int)Math.floor((double)xx/widthInt)*widthInt, yy-(int)Math.floor((double)yy/widthInt)*widthInt);

                    xl = (double)xx;
                    yl = (double)yy;

                    // add contribution of current particle
                    px += 100*Math.exp(-( (xl-X[k][t])*(xl-X[k][t]) + (yl-Y[k][t])*(yl-Y[k][t]) )/(as2)  )/s2;  // Gaussian point spread function

                    // replace value
                    ip1.putPixelValue(xx-(int)Math.floor((double)xx/widthInt)*widthInt, yy-(int)Math.floor((double)yy/widthInt)*widthInt, px);

                    //}

                }


            }

        }

    }

    private void waitForCompletion(Future<?>[] futures, String name) {
        try {
            ConcurrencyUtils.waitForCompletion(futures);
        } catch (InterruptedException ex) {
            IJ.log("Interruption Exception "+name);
            IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        } catch (ExecutionException ex) {
            IJ.log("Execution Exception "+name);
            IJ.log("LocMessage --> " + ex.getLocalizedMessage());
            ex.printStackTrace();

        }
    }


}
